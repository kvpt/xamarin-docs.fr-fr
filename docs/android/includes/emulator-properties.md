|Propriété|Description|Options|
|--- |--- |--- |
|`abi.type`|**Type d’ABI** &ndash; Spécifie le type d’ABI (interface binaire d’application) de l’appareil émulé. Le **x86** option est de l’instruction de définir communément appelés « x86 » ou « IA-32. » Le **x86_64** option concerne le x86 64 bits jeu d’instructions. Le **armeabi-v7a** option est destinée au jeu d’instructions ARM avec les extensions ARM v7-a. Le **arm64-v8a** option concerne le jeu d’instructions ARM qui prend en charge AArch64.|x86, x86_64, armeabi-v7a, arm64-v8a|
|`disk.cachePartition`|**Partition de cache** &ndash; détermine si l’appareil émulé doit utiliser un **/cache** partition sur l’appareil. Le **/cache** partition (qui est initialement vide) est l’emplacement où Android stocke les données fréquemment sollicitées et composants de l’application. Si la valeur **aucun**, l’émulateur n’utilise pas un **/cache** partition et l’autre `disk.cache` paramètres seront ignorés.|yes, no|
|`disk.cachePartition.path`|**Chemin d’accès de la partition du cache** &ndash; spécifie un fichier image de partition de cache sur votre ordinateur de développement. L’émulateur utilise ce fichier pour le **/cache** partition. Entrez un chemin d’accès absolu ou un chemin d’accès relatif au répertoire de données de l’émulateur. Si ne pas définie, l’émulateur crée un fichier temporaire vide appelé **cache.img** sur votre ordinateur de développement. Si le fichier n’existe pas, il est créé comme un fichier vide. Cette option est ignorée si `disk.cachePartition` a la valeur **aucun**.||
|`disk.cachePartition.size`|**Taille de partition du cache** &ndash; la taille du fichier de partition de cache (en octets). Vous n’avez normalement pas besoin de définir cette option, sauf si l’application télécharge des fichiers très volumineux qui dépassent la taille de cache par défaut de 66 mégaoctets. Cette option est ignorée si `disk.cachePartition` a la valeur **aucun**. Si cette valeur est un entier, il spécifie la taille en octets. Vous pouvez également spécifier la taille en kilo-octets, mégaoctets et gigaoctets en ajoutant **K**, **M**, ou **G** à la valeur. La taille minimale est **9M** et la taille maximale est **1 023 G**.||
|`disk.dataPartition.initPath`|**Chemin d’accès initial à la partition de données** &ndash; Spécifie le contenu initial de la partition de données. Après le nettoyage des données utilisateur, l’émulateur copie le contenu du fichier spécifié pour les données utilisateur (par défaut, **userdata-qemu.img**) au lieu d’utiliser **userdata.img** en tant que la version initiale.||
|`disk.dataPartition.path`|**Chemin d’accès à la partition de données** &ndash; Spécifie le fichier de partition de données utilisateur. Pour configurer un fichier de données utilisateur persistant, entrez un nom de fichier et un chemin d’accès sur votre ordinateur de développement. Si le fichier n’existe pas, l’émulateur crée une image à partir du fichier par défaut **userdata.img**, il stocke le nom de fichier spécifié par `disk.dataPartition.path`, et conserve les données de l’utilisateur lui lorsque l’émulateur s’arrête. Si vous ne spécifiez pas un chemin d’accès, le fichier par défaut est nommé **userdata-qemu.img**. La valeur spéciale **<temp>** , l’émulateur créer et utiliser un fichier temporaire. Si `disk.dataPartition.initPath` est défini, son contenu sera copié vers le `disk.dataPartition.path` fichier au moment du démarrage. Notez que cette option ne peut pas être vide.||
|`disk.dataPartition.size`|**Taille de partition de données** &ndash; spécifie la taille de la partition de données utilisateur en octets. Si cette valeur est un entier, il spécifie la taille en octets. Vous pouvez également spécifier la taille en kilo-octets, mégaoctets et gigaoctets en ajoutant **K**, **M**, ou **G** à la valeur. La taille minimale est **9M** et la taille maximale est **1 023 G**.||
|`disk.ramdisk.path`|**Chemin d’accès de disque virtuel** &ndash; chemin d’accès à l’image de partition (ramdisk) de démarrage. L’image ramdisk est un sous-ensemble de l’image système chargé par le noyau avant que l’image système soit montée. L’image ramdisk contient généralement des fichiers binaires de démarrage et des scripts d’initialisation. Si cette option n’est pas spécifiée, la valeur par défaut est **ramdisk.img** dans le répertoire système l’émulateur.||
|`disk.snapStorage.path`|**Chemin d’accès de stockage de capture instantanée** &ndash; chemin d’accès du fichier de stockage snapshot où tous les instantanés sont stockés. Toutes les captures instantanées effectuées pendant l’exécution seront enregistrées dans ce fichier. Seules les captures instantanées enregistrées dans ce fichier peuvent être restaurées au cours de l’exécution de l’émulateur. Si cette option n’est pas spécifiée, la valeur par défaut est snapshots.img dans le répertoire de données d’émulateur.||
|`disk.systemPartition.initPath`|**Le chemin d’accès de système partition init** &ndash; chemin d’accès à la copie en lecture seule du fichier image du système ; plus précisément, la partition contenant les bibliothèques de système et les données correspondant au niveau de l’API et de type variant. Si ce chemin d’accès n’est pas spécifié, la valeur par défaut est Ramdisk.img dans le répertoire système l’émulateur.||
|`disk.systemPartition.path`|**Chemin d’accès de la partition système** &ndash; chemin d’accès à l’image de partition système en lecture/écriture. Si ce chemin d’accès n’est pas définie, un fichier temporaire est créé et initialisé à partir du contenu du fichier spécifié par `disk.systemPartition.initPath`.||
|`disk.systemPartition.size`|**Taille de la partition système** &ndash; la taille idéale de la partition système (en octets). La taille est ignorée si l’image de la partition système est supérieure à ce paramètre ; dans le cas contraire, il spécifie la taille maximale que peut atteindre le fichier de partition système. Si cette valeur est un entier, il spécifie la taille en octets. Vous pouvez également spécifier la taille en kilo-octets, mégaoctets et gigaoctets en ajoutant **K**, **M**, ou **G** à la valeur. La taille minimale est **9M** et la taille maximale est **1 023 G**.||
|`hw.accelerometer`|**Accéléromètre** &ndash; détermine si l’appareil émulé contient un capteur d’accéléromètre. L’accéléromètre permet à l’appareil de déterminer l’orientation (utilisée pour la rotation automatique). L’accéléromètre signale l’accélération de l’appareil le long des trois axes du capteur.|yes, no|
|`hw.audioInput`|**Prise en charge de l’enregistrement audio** &ndash; détermine si l’appareil émulé peut enregistrer le contenu audio.|yes, no|
|`hw.audioOutput`|**Prise en charge de la lecture audio** &ndash; détermine si l’appareil émulé peut lire un fichier audio.|yes, no|
|`hw.battery`|**Prise en charge de la batterie** &ndash; détermine si l’appareil émulé peut s’exécuter sur une batterie.|yes, no|
|`hw.camera`|**Prise en charge de l’appareil photo** &ndash; détermine si l’appareil émulé a une caméra.|yes, no|
|`hw.camera.back`|**Caméra arrière** &ndash; configure la caméra arrière (les faces des filtres éloignées de l’utilisateur). Si vous utilisez une webcam sur votre ordinateur de développement pour simuler la caméra arrière sur l’appareil émulé, cette valeur doit être définie à la webcam*n*, où _n_ sélectionne la webcam (si vous n’avez qu’une seule webcam, Choisissez **webcam0**). Si défini sur émulé, l’émulateur simule la caméra dans le logiciel. Pour désactiver la caméra arrière, définissez cette valeur sur none. Si vous activez la caméra arrière, veillez à activer également `hw.camera`.|emulated, none, webcam0|
|`hw.camera.front`|**Caméra** &ndash; configure la caméra (les faces des filtres vers l’utilisateur). Si vous utilisez une webcam sur votre ordinateur de développement pour simuler la caméra sur l’appareil émulé, cette valeur doit être définie à la webcam*n*, où _n_ sélectionne la webcam (si vous n’avez qu’une seule webcam Choisissez **webcam0**). Si défini sur émulé, l’émulateur simule une caméra dans le logiciel. Pour désactiver la caméra, définissez cette valeur sur none. Si vous activez la caméra, veillez à activer également `hw.camera`.|emulated, none, webcam0|
|`hw.camera.maxHorizontalPixels`|**Pixels de la caméra horizontale maximale** &ndash; configure la résolution horizontale maximale de l’appareil photo de l’appareil émulé (en pixels).||
|`hw.camera.maxVerticalPixels`|**Pixels de la caméra verticale maximale** &ndash; configure la résolution verticale maximale de l’appareil photo de l’appareil émulé (en pixels).||
|`hw.cpu.arch`|**Architecture d’UC** &ndash; architecture de l’UC pour être émulée par l’appareil virtuel. Si vous utilisez Intel HAXM pour l’accélération matérielle, sélectionnez **x86** pour un processeur 32 bits. Sélectionnez **x86_64** pour un appareil accéléré par HAXM de 64 bits. (Veillez à installer l’image du système Intel x86 correspondante dans le Gestionnaire de kit de développement logiciel : par exemple, Intel x86 Atom ou Intel x86 Atom_64.) Pour simuler une UC ARM, sélectionnez **arm** pour 32 bits ou sélectionnez **arm64** pour une UC ARM de 64 bits. Gardez à l’esprit que les appareils virtuels ARM s’exécuteront beaucoup plus lentement que ceux de x86, car l’accélération matérielle n’est pas disponible pour ARM.|x86, x86_64, arm, arm64|
|`hw.cpu.model`|**Modèle de processeur** &ndash; cette valeur est normalement laissée non définie (elle sera définie sur une valeur qui est dérivée de `hw.cpu.arch` si elle n’est pas explicitement définie). Toutefois, elle peut être définie sur une chaîne spécifique à l’émulateur pour une utilisation expérimentale.||
|`hw.dPad`|**Les clés DPad** &ndash; détermine si l’appareil émulé prend en charge les clés du pavé directionnel (DPad). Un DPad a en général quatre clés pour indiquer le contrôle directionnel.|yes, no|
|`hw.gps`|**Support GPS** &ndash; détermine si l’appareil émulé possède un récepteur GPS (Global Positioning System).|yes, no|
|`hw.gpu.enabled`|**Émulation du GPU** &ndash; détermine si l’appareil émulé prend en charge l’émulation du GPU. Une fois activée, l’émulation du GPU utilise Open GL pour systèmes intégrés (OpenGL ES) pour le rendu des graphiques 2D et 3D sur l’écran et le paramètre Mode d’émulation du GPU associé détermine comment l’émulation du GPU est implémentée.|yes, no|
|`hw.gpu.mode`|**Mode d’émulation du GPU** &ndash; détermine comment l’émulation du GPU est implémentée par l’émulateur. Si vous sélectionnez automatique, l’émulateur choisira l’accélération matérielle et logicielle en fonction de la configuration de votre ordinateur de développement. Si vous sélectionnez hôte, l’émulateur utilisera le processeur graphique de votre ordinateur de développement pour effectuer l’émulation du GPU pour un rendu plus rapide. Si votre GPU n’est pas compatible avec l’émulateur et que vous utilisez Windows, vous pouvez essayer d’angle au lieu de l’hôte. Le mode d’angle utilise DirectX pour fournir des performances semblables à l’hôte. Si vous sélectionnez mesa, l’émulateur utilise la bibliothèque de logiciels 3D Mesa pour rendre des graphiques. Sélectionnez mesa si vous rencontrez des problèmes de rendu via le processeur graphique de votre ordinateur de développement. Le mode de swiftshader peut être utilisé pour restituer des graphiques dans le logiciel avec des performances légèrement moindres qu’à l’aide du GPU de votre ordinateur. L’option off (désactiver l’émulation matérielle graphique) est une option déconseillée qui peut provoquer un rendu inapproprié pour certains éléments et est donc pas recommandée.|auto, host, mesa, angle, swiftshader, off|
|`hw.gsmModem`|**Prise en charge du modem GSM** &ndash; détermine si l’appareil émulé inclut un modem qui prend en charge le système radio de téléphonie GSM (Global System for Mobile Communications).|yes, no|
|`hw.initialOrientation`|**Orientation de l’écran d’initiale** &ndash; configure l’orientation initiale de l’écran sur l’appareil émulé (mode portrait ou paysage). En mode portrait, l’écran est plus haut que large. En mode paysage, l’écran est plus large que haut. Lors de l’exécution de l’appareil émulé, vous pouvez modifier l’orientation si le mode portrait et le mode paysage sont tous les deux pris en charge dans le profil de l’appareil.|portrait, landscape|
|`hw.keyboard`|**Prise en charge du clavier** &ndash; détermine si l’appareil émulé prend en charge un clavier AZERTY.|yes, no|
|`hw.keyboard.charmap`|**Nom Charmap du clavier** &ndash; le nom du charmap matériel pour cet appareil. Remarque : Cela doit toujours être la valeur par défaut **qwerty2** , sauf si vous avez modifié l’image du système en conséquence. Ce nom est envoyé au noyau au moment du démarrage. L’utilisation d’un nom incorrect entraîne un appareil virtuel inutilisable.||
|`hw.keyboard.lid`|**Prise en charge du capot du clavier** &ndash; prise en charge du clavier est activée, ce paramètre détermine si le clavier AZERTY peut être fermé/masqué ou ouvert/visible. Ce paramètre est ignoré si hw.keyboard est défini sur false. Remarque : la valeur par défaut est false si l’appareil émulé cible le niveau d’API 12 ou une version ultérieure.|yes, no|
|`hw.lcd.backlight`|**Rétro-éclairage LCD** &ndash; détermine si un rétro-éclairage LCD est simulé par l’appareil émulé.|yes, no|
|`hw.lcd.density`|**Densité LCD** &ndash; la densité de l’affichage LCD émulé, mesurée en pixels indépendants de densité, ou point de distribution (dp est une unité de pixel virtuelle). Lorsque le paramètre est de 160 dp, chaque dp correspond à un pixel physique. Lors de l’exécution, Android utilise cette valeur pour sélectionner et mettre à l’échelle les ressources/composants appropriés pour un rendu d’affichage correct.|120, 160, 240, 213, 320|
|`hw.lcd.depth`|**Profondeur de couleurs LCD** &ndash; bit-profondeur de couleur du framebuffer émulé qui contient le bitmap de pilotage de l’écran LCD. Cette valeur peut être de 16 bits (65 536 couleurs possibles) ou 32 bits (16 777 216 couleurs plus la transparence). Le paramètre de 32 bits permet à l’émulateur de s’exécuter légèrement plus lentement mais avec une meilleure précision des couleurs.|16, 32|
|`hw.lcd.height`|**Hauteur des pixels LCD** &ndash; le nombre de pixels qui composent la dimension verticale de l’affichage LCD émulé.||
|`hw.lcd.width`|**Largeur des pixels LCD** &ndash; le nombre de pixels qui composent la dimension horizontale de l’affichage LCD émulé.||
|`hw.mainKeys`|**Clés de serveur/accueil matériel** &ndash; détermine si l’appareil émulé prend en charge le retour physique et les boutons de navigation accueil. Vous pouvez définir cette valeur sur **Oui** si les boutons sont implémentées uniquement dans le logiciel. Si `hw.mainKeys` a la valeur **Oui**, l’émulateur n’affichera pas les boutons de navigation sur l’écran, mais vous pouvez utiliser le panneau côté émulateur pour « appuyez sur « ces boutons.|yes, no|
|`hw.ramSize`|**Taille de la RAM appareil** &ndash; la quantité de RAM physique sur l’appareil émulé, en mégaoctets. La valeur par défaut est calculée à partir de la taille de l’écran ou de la version de l’apparence. L’augmentation de la taille peut fournir des opérations d’émulation plus rapide, mais au détriment d’une demande de ressources plus importante à partir de votre ordinateur de développement.||
|`hw.screen`|**Type d’écran tactile** &ndash; définit le type d’écran sur l’appareil émulé. Un écran tactile multipoint peut suivre deux ou plusieurs doigts sur l’interface tactile. Un écran tactile peut détecter uniquement les événements tactiles d’un seul doigt. Un écran non tactile ne détecte pas les événements tactiles.|touch, multi-touch, no-touch|
|`hw.sdCard`|**Prise en charge de SDCard** &ndash; détermine si l’appareil émulé prend en charge l’insertion et la suppression de cartes SD (Secure Digital) virtuelles. L’émulateur utilise des images de disque monté stockées sur votre ordinateur de développement pour simuler les partitions des périphériques de carte SD réels (voir hw.sdCard.path).|yes, no|
|`sdcard.size`|**Taille de la SDCard** &ndash; spécifie la taille du fichier de carte SD virtuel à l’emplacement spécifié par `hw.sdCard.path`. disponible sur l’appareil (en octets). Si cette valeur est un entier, il spécifie la taille en octets. Vous pouvez également spécifier la taille en kilo-octets, mégaoctets et gigaoctets en ajoutant **K**, **M**, ou **G** à la valeur. La taille minimale est **9M** et la taille maximale est **1 023 G**.||
|`hw.sdCard.path`|**Chemin de l’Image SDCard** &ndash; Spécifie le nom de fichier et le chemin d’accès à un fichier d’image de la partition de carte SD sur votre ordinateur de développement. Par exemple, ce chemin d’accès peut être défini **C:\sd\sdcard.img** sur Windows.||
|`hw.sensors.magnetic_field`|**Capteur de champ magnétique** &ndash; détermine si l’appareil émulé prend en charge un capteur de champ magnétique. Le capteur de champ magnétique (également appelé magnétomètre) signale le champ géomagnétique ambiant mesuré le long des trois axes du capteur. Activez ce paramètre pour les applications qui ont besoin d’accéder à une lecture de boussole. Par exemple, une application de navigation peut utiliser ce capteur pour détecter la direction des faces utilisateurs.|yes, no|
|`hw.sensors.orientation`|**Capteur d’orientation** &ndash; détermine si l’appareil émulé fournit l’orientation des valeurs de capteur. Le capteur d’orientation mesure les degrés de rotation d’un appareil autour des trois axes physiques (x, y, z). Notez que le capteur d’orientation est déconseillé à compter d’Android 2.2 (API niveau 8).|yes, no|
|`hw.sensors.proximity`|**Capteur de proximité** &ndash; détermine si l’appareil émulé prend en charge un capteur de proximité. Ce capteur mesure la proximité d’un objet par rapport à l’écran d’affichage d’un appareil. Ce capteur est généralement utilisé pour déterminer si un combiné est actuellement tenu à proximité de l’oreille d’une personne.|yes, no|
|`hw.sensors.temperature`|**Capteur de température** &ndash; détermine si l’appareil émulé prend en charge un capteur de température. Ce capteur mesure la température de l’appareil en degrés Celsius (&deg;C).|yes, no|
|`hw.touchScreen`|**Prise en charge de l’écran tactile** &ndash; détermine si l’appareil émulé prend en charge un écran tactile. L’écran tactile est utilisé pour la manipulation directe d’objets à l’écran.|yes, no|
|`hw.trackBall`|**Prise en charge du trackball** &ndash; détermine si l’appareil émulé prend en charge un trackball.|yes, no|
|`hw.useext4`|**Prise en charge de système de fichiers EXT4** &ndash; détermine si l’appareil émulé utilise le système de fichiers Linux EXT4 pour les partitions. Étant donné que le type de système de fichiers est désormais détecté automatiquement, cette option est déconseillée et ignorée.|Non|
|`kernel.newDeviceNaming`|**Noyau nouveau dispositif d’affectation de noms** &ndash; permet de spécifier si le noyau requiert un nouveau modèle d’affectation de noms d’appareil. Cela est généralement utilisé avec les noyaux Linux 3.10 et versions ultérieures. Si la valeur **autodetect**, l’émulateur détectera automatiquement si le noyau requiert un nouveau modèle d’affectation de noms d’appareil.|autodetect, yes, no|
|`kernel.parameters`|**Paramètres de noyau** &ndash; spécifie la chaîne de paramètres de démarrage du noyau Linux. Par défaut, ce paramètre est laissé vide.||
|`kernel.path`|**Chemin d’accès de noyau** &ndash; Spécifie le chemin d’accès au noyau Linux. Si ce chemin d’accès n’est pas spécifié, l’émulateur recherche dans le répertoire de système d’émulateur pour Ramdisk.img.||
|`kernel.supportsYaffs2`|**Prise en charge de la partition YAFFS2** &ndash; détermine si le noyau prend en charge YAFFS2 (encore une autre Flash fichier système 2) partitions. En règle générale, cela s’applique uniquement aux noyaux avant Linux 3.10. Si la valeur **autodetect** l’émulateur détectera automatiquement si le noyau peut monter des systèmes de fichiers YAFFS2.|autodetect, yes, no|
|`skin.name`|**Nom de l’apparence** &ndash; le nom d’une apparence d’émulateur Android. Une apparence est une collection de fichiers qui définit les éléments visuels et de contrôle d’un affichage de l’émulateur ; elle décrit l’aspect de la fenêtre de l’appareil virtuel Android sur votre ordinateur de développement. Une apparence décrit la taille, les boutons et la conception générale de l’écran, mais elle n’affecte pas le fonctionnement de votre application.||
|`skin.path`|**Chemin d’accès de l’apparence** &ndash; chemin d’accès au répertoire qui contient les fichiers d’apparence émulateur spécifié dans skin.name ce répertoire contient les fichiers de disposition hardware.ini et fichiers d’image pour les éléments d’affichage de l’apparence.||
|`skin.dynamic`|**Apparence dynamique** &ndash; ou non l’apparence est dynamique. L’apparence de l’émulateur est une apparence dynamique si l’émulateur consiste à construire une apparence d’une taille donnée, selon une largeur et une hauteur spécifiées.|Non|

